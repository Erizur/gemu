#include "frontend.h"
#include <stddef.h>
#include <stdint.h>
#include "SDL3/SDL_events.h"
#include "SDL3/SDL_log.h"
#include "SDL3/SDL_pixels.h"
#include "SDL3/SDL_rect.h"
#include "SDL3/SDL_render.h"
#include "SDL3/SDL_timer.h"
#include "core/game_boy.h"

#define FPS 60
#define DELTA (1.0 / FPS)
#define ASPECT_RATIO ((double)GB_LCD_WIDTH / GB_LCD_HEIGHT)

static const SDL_FRect TEXTURE_RECT = {0.0, 0.0, GB_BG_WIDTH, GB_BG_HEIGHT};

static const uint8_t PALETTE_RGB[][3] = {
    {186, 218, 85},
    {130, 153, 59},
    { 74,  87, 34},
    { 19,  22,  8}
};

void handle_event(State* const restrict state, const SDL_Event* const restrict event) {
    switch (event->type) {
        case SDL_EVENT_QUIT: {
            state->quit = true;
            break;
        }
        case SDL_EVENT_WINDOW_RESIZED: {
            state->window_width = event->window.data1;
            state->window_height = event->window.data2;
            break;
        }
        default: {
        }
    }
}

void update(State* const restrict state, const double delta) {
    const double frame_cycles = GB_CPU_FREQ_M * delta;
    state->gb.cycle_count = 0;

    while (state->gb.cycle_count < frame_cycles) {
        const double progress = (double)state->gb.cycle_count / frame_cycles;
        state->gb.ly = progress * GB_LCD_MAX_LY;
        GameBoy_tick(&state->gb);
    }
}

bool update_texture(const State* const restrict state) {
    SDL_Surface* surface = NULL;

    if (!SDL_LockTextureToSurface(state->texture, NULL, &surface)) {
        return false;
    }

    const SDL_PixelFormatDetails* const pixel_format = SDL_GetPixelFormatDetails(surface->format);

    if (pixel_format == NULL) {
        return false;
    }

    SDL_FillSurfaceRect(surface, NULL, SDL_MapRGB(pixel_format, NULL, 0, 0, 0));

    if (state->gb.lcdc & LCDC_ENABLE) {
        uint32_t* const restrict pixels = surface->pixels;

        for (size_t y = 0; y < GB_BG_HEIGHT; y++) {
            for (size_t x = 0; x < GB_BG_WIDTH; x++) {
                pixels[(y * surface->w) + x] = SDL_MapRGB(
                    pixel_format,
                    NULL,
                    255.0 * ((double)x / GB_BG_WIDTH),
                    255.0 * ((double)y / GB_BG_HEIGHT),
                    0
                );
            }
        }

        const size_t tile_data = state->gb.lcdc & LCDC_BGW_TILE_AREA ? 0 : 0x1000;
        const size_t tile_map = state->gb.lcdc & LCDC_BG_TILE_MAP ? 0x1C00 : 0x1800;

        for (size_t tile_y = 0; tile_y < 32; tile_y++) {
            for (size_t tile_x = 0; tile_x < 32; tile_x++) {
                const uint8_t tile_index = state->gb.vram[tile_map + (tile_y * 32) + tile_x];
                const long tile_index_signed =
                    state->gb.lcdc & LCDC_BGW_TILE_AREA ? tile_index : (int8_t)tile_index;

                for (size_t y = 0; y < 8; y++) {
                    const uint8_t byte_1 =
                        state->gb.vram[tile_data + (tile_index_signed * 16) + (2 * y)];
                    const uint8_t byte_2 =
                        state->gb.vram[tile_data + (tile_index_signed * 16) + (2 * y) + 1];

                    for (size_t x = 0; x < 8; x++) {
                        const uint8_t bit_lo = (byte_1 >> x) & 1;
                        const uint8_t bit_hi = (byte_2 >> x) & 1;
                        const uint8_t palette_index = bit_lo | (bit_hi << 1);

                        const uint8_t color = (state->gb.bgp >> (palette_index * 2)) & 0x3;

                        pixels[(((tile_y * 8) + y) * surface->w) + (tile_x * 8) + 7 - x] =
                            SDL_MapRGB(
                                pixel_format,
                                NULL,
                                PALETTE_RGB[color][0],
                                PALETTE_RGB[color][1],
                                PALETTE_RGB[color][2]
                            );
                    }
                }
            }
        }
    }

    SDL_UnlockTexture(state->texture);
    return true;
}

void render(const State* const restrict state, SDL_Renderer* const restrict renderer) {
    if (!update_texture(state)) {
        SDL_LogWarn(SDL_LOG_CATEGORY_ERROR, "Could not update texture: %s", SDL_GetError());
    }

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
    SDL_RenderClear(renderer);

    SDL_FRect src_rect = {state->gb.scx, state->gb.scy, GB_LCD_WIDTH, GB_LCD_HEIGHT};

    const double real_aspect_ratio = (double)state->window_width / state->window_height;
    SDL_FRect dest_rect;

    if (real_aspect_ratio == ASPECT_RATIO) {
        // Window is exactly the right aspect ratio
        dest_rect.w = state->window_width;
        dest_rect.h = state->window_height;
        dest_rect.x = 0.0;
        dest_rect.y = 0.0;
    } else if (real_aspect_ratio > ASPECT_RATIO) {
        // Window is stretched out horizontally
        dest_rect.w = state->window_height * ASPECT_RATIO;
        dest_rect.h = state->window_height;
        dest_rect.x = (state->window_width / 2.0) - (dest_rect.w / 2);
        dest_rect.y = 0.0;
    } else {
        // Window is stretched out vertically
        dest_rect.w = state->window_width;
        dest_rect.h = state->window_width / ASPECT_RATIO;
        dest_rect.x = 0.0;
        dest_rect.y = (state->window_height / 2.0) - (dest_rect.h / 2);
    }

    SDL_RenderTexture(renderer, state->texture, &src_rect, &dest_rect);
    SDL_RenderPresent(renderer);
}

void frame(State* const restrict state, SDL_Renderer* const restrict renderer) {
    SDL_Event event;

    while (SDL_PollEvent(&event)) {
        handle_event(state, &event);
    }

    const double new_time = SDL_GetTicks() / 1000.0;
    state->time_accumulator += new_time - state->current_time;
    state->current_time = new_time;

    while (state->time_accumulator >= DELTA) {
        update(state, DELTA);
        state->time_accumulator -= DELTA;
    }

    render(state, renderer);
    SDL_DelayNS(DELTA * 1e9);
}
